<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Explorer 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #eee;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #startMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #startMenu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 48px;
            color: #4a90e2;
            margin-bottom: 60px;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            text-align: center;
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 400px;
        }

        .menu-item {
            background: rgba(74, 144, 226, 0.1);
            border: 2px solid #4a90e2;
            padding: 20px 30px;
            font-size: 24px;
            color: #4a90e2;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            border-radius: 8px;
        }

        .menu-item:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .menu-item.disabled {
            opacity: 0.5;
            cursor: default;
        }

        .menu-item.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .quick-maze-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .quick-maze-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-label {
            font-size: 14px;
            color: #888;
        }

        .control-input {
            background: rgba(0,0,0,0.3);
            border: 1px solid #4a90e2;
            color: #4a90e2;
            padding: 8px 12px;
            font-size: 18px;
            border-radius: 5px;
            width: 150px;
            font-family: 'Courier New', monospace;
        }

        .windows-mode-toggle {
            background: rgba(74, 144, 226, 0.1);
            border: 2px solid #4a90e2;
            padding: 15px 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s;
        }

        .windows-mode-toggle:hover {
            background: rgba(74, 144, 226, 0.2);
        }

        .toggle-label {
            font-size: 18px;
            color: #4a90e2;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            border: 2px solid #4a90e2;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: rgba(74, 144, 226, 0.5);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: #4a90e2;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
            background: #00ff88;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            image-rendering: pixelated;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #minimapCanvas {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #4a90e2;
            background: #000;
            border-radius: 5px;
            z-index: 20;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            z-index: 5;
        }

        #win {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,255,100,0.95);
            color: #000;
            padding: 40px;
            border-radius: 15px;
            font-size: 32px;
            font-weight: bold;
            display: none;
            text-align: center;
            z-index: 100;
        }

        .btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #000;
            color: #00ff88;
            border: 2px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .btn:hover {
            background: #00ff88;
            color: #000;
        }

        #resetBtn, #menuBtn {
            margin-top: 10px;
            padding: 5px 10px;
            font-size: 12px;
            background: rgba(255,51,102,0.2);
            color: #ff3366;
            border: 1px solid #ff3366;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            width: 100%;
            display: block;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <div class="menu-title">MAZE EXPLORER 3D</div>
        <div class="menu-options">
            <div class="menu-item" id="campaignBtn">CAMPAIGN MODE</div>
            <div class="quick-maze-container">
                <div class="menu-item" id="quickMazeBtn">QUICK MAZE</div>
                <div class="quick-maze-controls">
                    <div class="control-group">
                        <div class="control-label">Level (1-8)</div>
                        <input type="number" class="control-input" id="quickLevel" value="1" min="1" max="8">
                    </div>
                    <div class="control-group">
                        <div class="control-label">Seed</div>
                        <input type="number" class="control-input" id="quickSeed" value="12345">
                    </div>
                </div>
            </div>
            <div class="windows-mode-toggle" id="windowsModeToggle">
                <span class="toggle-label">Windows Screensaver Mode</span>
                <div class="toggle-switch" id="toggleSwitch">
                    <div class="toggle-slider"></div>
                </div>
            </div>
            <div class="menu-item disabled">PATREON</div>
            <div class="menu-item disabled">PIX</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <canvas id="minimapCanvas"></canvas>
    <div id="crosshair">+</div>
    <div id="ui">
        <div>Mode: <span id="modeDisplay">Campaign</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Seed: <span id="seedDisplay">0</span></div>
        <div>Graphics: <span id="graphicsMode">Default</span></div>
        <button id="resetBtn">Reset Maze</button>
        <button id="menuBtn">Main Menu</button>
    </div>
    <div id="instructions">
        WASD - Move | Mouse - Look | Click to lock pointer
    </div>
    <div id="win">
        ðŸŽ‰ EXIT FOUND! ðŸŽ‰<br>
        <div style="font-size:16px; margin-top:10px;">Press SPACE or click below</div>
        <button class="btn" id="nextLevelBtn">Next Level</button>
        <button class="btn" id="menuBtn2">Main Menu</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1400;
        canvas.height = 900;

        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapSize = 200;
        minimapCanvas.width = minimapSize;
        minimapCanvas.height = minimapSize;

        // Game state
        let windowsMode = false;
        let gameMode = 'campaign';
        let quickMazeConfig = { level: 1, seed: 12345 };
        let gameState = { level: 1, seed: Date.now(), won: false };
        let maze, player;
        let pointerLocked = false;

        // Texture generation
        function generateBrickTexture() {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 64;
            texCanvas.height = 64;
            const texCtx = texCanvas.getContext('2d');

            // Background (mortar)
            texCtx.fillStyle = '#e0e0e0';
            texCtx.fillRect(0, 0, 64, 64);

            // Draw bricks
            const brickHeight = 16;
            const brickWidth = 32;
            const mortarSize = 2;

            for (let y = 0; y < 4; y++) {
                const offsetX = (y % 2) * (brickWidth / 2);
                for (let x = -1; x < 3; x++) {
                    const bx = x * brickWidth + offsetX;
                    const by = y * brickHeight;

                    // Brick color with slight variation
                    const variation = Math.random() * 20 - 10;
                    const r = Math.max(0, Math.min(255, 180 + variation));
                    const g = Math.max(0, Math.min(255, 40 + variation));
                    const b = Math.max(0, Math.min(255, 40 + variation));
                    
                    texCtx.fillStyle = `rgb(${r},${g},${b})`;
                    texCtx.fillRect(
                        bx + mortarSize,
                        by + mortarSize,
                        brickWidth - mortarSize * 2,
                        brickHeight - mortarSize * 2
                    );

                    // Add some texture to bricks
                    for (let i = 0; i < 5; i++) {
                        const tx = bx + Math.random() * brickWidth;
                        const ty = by + Math.random() * brickHeight;
                        texCtx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                        texCtx.fillRect(tx, ty, 2, 2);
                    }
                }
            }

            return texCanvas;
        }

        function generateCarpetTexture() {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 64;
            texCanvas.height = 64;
            const texCtx = texCanvas.getContext('2d');

            // Base carpet color
            texCtx.fillStyle = '#d4a850';
            texCtx.fillRect(0, 0, 64, 64);

            // Add noise/texture
            for (let y = 0; y < 64; y++) {
                for (let x = 0; x < 64; x++) {
                    if (Math.random() > 0.7) {
                        const brightness = Math.random() * 40 - 20;
                        const r = Math.max(0, Math.min(255, 212 + brightness));
                        const g = Math.max(0, Math.min(255, 168 + brightness));
                        const b = Math.max(0, Math.min(255, 80 + brightness));
                        texCtx.fillStyle = `rgb(${r},${g},${b})`;
                        texCtx.fillRect(x, y, 1, 1);
                    }
                }
            }

            return texCanvas;
        }

        const brickTexture = generateBrickTexture();
        const carpetTexture = generateCarpetTexture();
        
        // Cache texture pixel data for faster access
        const brickTextureData = brickTexture.getContext('2d').getImageData(0, 0, 64, 64).data;
        const carpetTextureData = carpetTexture.getContext('2d').getImageData(0, 0, 64, 64).data;

        // Windows mode toggle
        document.getElementById('windowsModeToggle').addEventListener('click', () => {
            windowsMode = !windowsMode;
            const toggleSwitch = document.getElementById('toggleSwitch');
            if (windowsMode) {
                toggleSwitch.classList.add('active');
            } else {
                toggleSwitch.classList.remove('active');
            }
            updateUI();
        });

        // Seeded random number generator
        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }

        // Maze generator
        class Maze {
            constructor(cols, rows, seed) {
                this.cols = cols;
                this.rows = rows;
                this.cellSize = 64;
                this.grid = [];
                this.rng = new Random(seed);
                
                for (let y = 0; y < rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < cols; x++) {
                        this.grid[y][x] = {
                            walls: { top: true, right: true, bottom: true, left: true },
                            visited: false
                        };
                    }
                }
                
                this.generate(0, 0);
                this.exitX = this.cols - 1;
                this.exitY = this.rows - 1;
                this.grid[this.exitY][this.exitX].isExit = true;
            }

            generate(x, y) {
                const stack = [[x, y]];
                
                while (stack.length > 0) {
                    const [cx, cy] = stack[stack.length - 1];
                    this.grid[cy][cx].visited = true;
                    
                    const directions = [
                        { dx: 0, dy: -1, wall: 'top', opposite: 'bottom' },
                        { dx: 1, dy: 0, wall: 'right', opposite: 'left' },
                        { dx: 0, dy: 1, wall: 'bottom', opposite: 'top' },
                        { dx: -1, dy: 0, wall: 'left', opposite: 'right' }
                    ];
                    
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(this.rng.next() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    let foundUnvisited = false;
                    for (const dir of directions) {
                        const nx = cx + dir.dx;
                        const ny = cy + dir.dy;
                        
                        if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows && !this.grid[ny][nx].visited) {
                            this.grid[cy][cx].walls[dir.wall] = false;
                            this.grid[ny][nx].walls[dir.opposite] = false;
                            stack.push([nx, ny]);
                            foundUnvisited = true;
                            break;
                        }
                    }
                    
                    if (!foundUnvisited) {
                        stack.pop();
                    }
                }
            }

            getCell(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                if (cellX < 0 || cellX >= this.cols || cellY < 0 || cellY >= this.rows) {
                    return null;
                }
                return this.grid[cellY][cellX];
            }

            markExplored(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                if (cellX >= 0 && cellX < this.cols && cellY >= 0 && cellY < this.rows) {
                    this.grid[cellY][cellX].explored = true;
                    const radius = 1;
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = cellX + dx;
                            const ny = cellY + dy;
                            if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                                this.grid[ny][nx].explored = true;
                            }
                        }
                    }
                }
            }

            drawMinimap(playerX, playerY) {
                minimapCtx.fillStyle = '#000';
                minimapCtx.fillRect(0, 0, minimapSize, minimapSize);

                const cellSize = Math.min(minimapSize / this.cols, minimapSize / this.rows);
                
                minimapCtx.strokeStyle = '#4a90e2';
                minimapCtx.lineWidth = 1;

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.grid[y][x];
                        
                        if (!cell.explored) continue;

                        const screenX = x * cellSize;
                        const screenY = y * cellSize;

                        if (x === 0 && y === 0) {
                            minimapCtx.fillStyle = '#ffaa00';
                            minimapCtx.fillRect(screenX + 1, screenY + 1, cellSize - 2, cellSize - 2);
                        }

                        if (cell.isExit) {
                            minimapCtx.fillStyle = '#00ff88';
                            minimapCtx.fillRect(screenX + 1, screenY + 1, cellSize - 2, cellSize - 2);
                        }

                        minimapCtx.beginPath();
                        if (cell.walls.top) {
                            minimapCtx.moveTo(screenX, screenY);
                            minimapCtx.lineTo(screenX + cellSize, screenY);
                        }
                        if (cell.walls.right) {
                            minimapCtx.moveTo(screenX + cellSize, screenY);
                            minimapCtx.lineTo(screenX + cellSize, screenY + cellSize);
                        }
                        if (cell.walls.bottom) {
                            minimapCtx.moveTo(screenX, screenY + cellSize);
                            minimapCtx.lineTo(screenX + cellSize, screenY + cellSize);
                        }
                        if (cell.walls.left) {
                            minimapCtx.moveTo(screenX, screenY);
                            minimapCtx.lineTo(screenX, screenY + cellSize);
                        }
                        minimapCtx.stroke();
                    }
                }

                const playerCellX = Math.floor(playerX / this.cellSize);
                const playerCellY = Math.floor(playerY / this.cellSize);
                minimapCtx.fillStyle = '#ff3366';
                minimapCtx.beginPath();
                minimapCtx.arc(
                    playerCellX * cellSize + cellSize / 2,
                    playerCellY * cellSize + cellSize / 2,
                    cellSize / 3,
                    0,
                    Math.PI * 2
                );
                minimapCtx.fill();
            }
        }

        // Player with raycasting
        class Player {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.pitch = 0;
                this.moveSpeed = 3;
                this.rotSpeed = 0.05;
                this.fov = Math.PI / 3;
                this.rayCount = canvas.width;
            }

            move(dx, dy, maze) {
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                if (!this.checkCollision(newX, this.y, maze)) {
                    this.x = newX;
                }
                if (!this.checkCollision(this.x, newY, maze)) {
                    this.y = newY;
                }
            }

            checkCollision(x, y, maze) {
                const cellX = Math.floor(x / maze.cellSize);
                const cellY = Math.floor(y / maze.cellSize);
                
                if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                    return true;
                }
                
                const cell = maze.grid[cellY][cellX];
                const localX = x % maze.cellSize;
                const localY = y % maze.cellSize;
                const margin = 8;
                
                if (localY < margin && cell.walls.top) return true;
                if (localY > maze.cellSize - margin && cell.walls.bottom) return true;
                if (localX < margin && cell.walls.left) return true;
                if (localX > maze.cellSize - margin && cell.walls.right) return true;
                
                return false;
            }

            checkExit(maze) {
                const cellX = Math.floor(this.x / maze.cellSize);
                const cellY = Math.floor(this.y / maze.cellSize);
                return cellX === maze.exitX && cellY === maze.exitY;
            }

            castRays(maze) {
                const rays = [];
                
                for (let i = 0; i < this.rayCount; i++) {
                    const rayAngle = this.angle - this.fov / 2 + (this.fov * i / this.rayCount);
                    const ray = this.castRay(rayAngle, maze);
                    rays.push(ray);
                }
                
                return rays;
            }

            castRay(angle, maze) {
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                let dist = 0;
                const step = 0.5;
                const maxDist = 1000;
                let hitWall = false;
                let hitCellX = -1;
                let hitCellY = -1;
                let wallSide = null;
                let hitX = 0;
                let hitY = 0;
                
                while (!hitWall && dist < maxDist) {
                    dist += step;
                    const testX = this.x + dx * dist;
                    const testY = this.y + dy * dist;
                    
                    const cellX = Math.floor(testX / maze.cellSize);
                    const cellY = Math.floor(testY / maze.cellSize);
                    
                    if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                        hitWall = true;
                        break;
                    }
                    
                    const cell = maze.grid[cellY][cellX];
                    const localX = testX % maze.cellSize;
                    const localY = testY % maze.cellSize;
                    
                    if (localY < 1 && cell.walls.top) {
                        hitWall = true;
                        hitCellX = cellX;
                        hitCellY = cellY;
                        wallSide = 'horizontal';
                        hitX = testX;
                        hitY = testY;
                    } else if (localY > maze.cellSize - 1 && cell.walls.bottom) {
                        hitWall = true;
                        hitCellX = cellX;
                        hitCellY = cellY;
                        wallSide = 'horizontal';
                        hitX = testX;
                        hitY = testY;
                    } else if (localX < 1 && cell.walls.left) {
                        hitWall = true;
                        hitCellX = cellX;
                        hitCellY = cellY;
                        wallSide = 'vertical';
                        hitX = testX;
                        hitY = testY;
                    } else if (localX > maze.cellSize - 1 && cell.walls.right) {
                        hitWall = true;
                        hitCellX = cellX;
                        hitCellY = cellY;
                        wallSide = 'vertical';
                        hitX = testX;
                        hitY = testY;
                    }
                }
                
                const isExit = (hitCellX === maze.exitX && hitCellY === maze.exitY);
                const isStart = (hitCellX === 0 && hitCellY === 0);
                
                return { dist, angle, isExit, isStart, wallSide, hitX, hitY };
            }

            render(maze) {
                const rays = this.castRays(maze);
                const pitchOffset = this.pitch * 300;
                
                // Create ImageData buffer for the entire screen
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const pixels = imageData.data;
                
                // Sky - black (already 0s)
                
                // Floor
                const horizonY = canvas.height / 2 + pitchOffset;
                
                if (windowsMode) {
                    // Draw textured floor directly to pixel buffer
                    for (let y = Math.max(0, Math.floor(horizonY)); y < canvas.height; y++) {
                        const floorDist = (canvas.height / 2) / (y - canvas.height / 2 - pitchOffset);
                        
                        for (let x = 0; x < canvas.width; x++) {
                            const rayAngle = this.angle - this.fov / 2 + (this.fov * x / canvas.width);
                            const floorX = this.x + Math.cos(rayAngle) * floorDist * 100;
                            const floorY = this.y + Math.sin(rayAngle) * floorDist * 100;
                            
                            // Multiply by 4 to make texture 4x smaller (tiles more)
                            let texX = Math.floor((Math.abs(floorX) * 4)) % 64;
                            let texY = Math.floor((Math.abs(floorY) * 4)) % 64;
                            
                            texX = Math.max(0, Math.min(63, texX));
                            texY = Math.max(0, Math.min(63, texY));
                            
                            const texIndex = (texY * 64 + texX) * 4;
                            const pixelIndex = (y * canvas.width + x) * 4;
                            
                            const brightness = Math.max(0.3, 1 - floorDist / 8);
                            pixels[pixelIndex] = carpetTextureData[texIndex] * brightness;
                            pixels[pixelIndex + 1] = carpetTextureData[texIndex + 1] * brightness;
                            pixels[pixelIndex + 2] = carpetTextureData[texIndex + 2] * brightness;
                            pixels[pixelIndex + 3] = 255;
                        }
                    }
                } else {
                    // Default floor
                    for (let y = Math.max(0, Math.floor(horizonY)); y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const pixelIndex = (y * canvas.width + x) * 4;
                            pixels[pixelIndex] = 10;
                            pixels[pixelIndex + 1] = 10;
                            pixels[pixelIndex + 2] = 20;
                            pixels[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                // Walls
                for (let i = 0; i < rays.length; i++) {
                    const ray = rays[i];
                    const correctedDist = ray.dist * Math.cos(ray.angle - this.angle);
                    const wallHeight = (maze.cellSize * 300) / correctedDist;
                    
                    const wallTop = (canvas.height - wallHeight) / 2 + pitchOffset;
                    const wallBottom = wallTop + wallHeight;
                    
                    if (windowsMode && !ray.isExit && !ray.isStart) {
                        // Draw textured brick wall
                        // Scale texture to tile properly (4x across a cell)
                        let worldPos = ray.wallSide === 'vertical' ? ray.hitY : ray.hitX;
                        let texX = Math.floor((Math.abs(worldPos) * 4)) % 64;
                        
                        texX = Math.max(0, Math.min(63, texX));
                        
                        for (let y = Math.max(0, Math.floor(wallTop)); y < Math.min(canvas.height, Math.ceil(wallBottom)); y++) {
                            // Map screen Y to world height and tile 4x
                            let worldHeight = ((y - wallTop) / wallHeight) * maze.cellSize;
                            let texY = Math.floor((worldHeight * 4)) % 64;
                            texY = Math.max(0, Math.min(63, texY));
                            
                            const texIndex = (texY * 64 + texX) * 4;
                            const pixelIndex = (y * canvas.width + i) * 4;
                            
                            let brightness = Math.max(0, 1 - correctedDist / 500);
                            if (ray.wallSide === 'vertical') {
                                brightness *= 0.7;
                            }
                            
                            pixels[pixelIndex] = brickTextureData[texIndex] * brightness;
                            pixels[pixelIndex + 1] = brickTextureData[texIndex + 1] * brightness;
                            pixels[pixelIndex + 2] = brickTextureData[texIndex + 2] * brightness;
                            pixels[pixelIndex + 3] = 255;
                        }
                    } else {
                        // Default colored walls
                        let brightness = Math.max(0, 1 - correctedDist / 500);
                        let r, g, b;
                        
                        if (ray.isExit) {
                            r = 0;
                            g = 255 * brightness;
                            b = 136 * brightness;
                        } else if (ray.isStart) {
                            r = 255 * brightness;
                            g = 170 * brightness;
                            b = 0;
                        } else {
                            if (ray.wallSide === 'vertical') {
                                brightness *= 0.7;
                            }
                            r = 74 * brightness;
                            g = 144 * brightness;
                            b = 226 * brightness;
                        }
                        
                        for (let y = Math.max(0, Math.floor(wallTop)); y < Math.min(canvas.height, Math.ceil(wallBottom)); y++) {
                            const pixelIndex = (y * canvas.width + i) * 4;
                            pixels[pixelIndex] = r;
                            pixels[pixelIndex + 1] = g;
                            pixels[pixelIndex + 2] = b;
                            pixels[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                // Draw the entire frame at once
                ctx.putImageData(imageData, 0, 0);
                
                this.drawHand();
            }

            drawHand() {
                const handWidth = 150;
                const handHeight = 200;
                const handX = canvas.width - handWidth - 20;
                const handY = canvas.height - handHeight;
                
                ctx.fillStyle = '#d4a574';
                
                ctx.beginPath();
                ctx.ellipse(handX + 60, handY + 120, 40, 50, 0, 0, Math.PI * 2);
                ctx.fill();
                
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(handX + 30 + i * 15, handY + 80 + i * 5, 12, 30, -0.2 + i * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.beginPath();
                ctx.ellipse(handX + 20, handY + 130, 15, 25, -0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(handX + 35, handY + 150, 50, 50);
            }
        }

        function startGame(mode, config = null) {
            gameMode = mode;
            document.getElementById('startMenu').classList.add('hidden');
            
            if (mode === 'campaign') {
                if (gameState.level > 8) gameState.level = 8;
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
            } else {
                quickMazeConfig = config;
                if (quickMazeConfig.level > 8) quickMazeConfig.level = 8;
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
            }
            
            maze.markExplored(player.x, player.y);
            updateUI();
            canvas.requestPointerLock();
        }

        function resetCurrentMaze() {
            if (gameMode === 'campaign') {
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
            } else {
                quickMazeConfig.seed = Date.now();
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                updateUI();
            }
            maze.markExplored(player.x, player.y);
        }

        function returnToMenu() {
            document.getElementById('startMenu').classList.remove('hidden');
            document.getElementById('win').style.display = 'none';
            gameState.won = false;
            document.exitPointerLock();
        }

        function updateUI() {
            if (gameMode === 'campaign') {
                document.getElementById('modeDisplay').textContent = 'Campaign';
                document.getElementById('level').textContent = gameState.level;
                document.getElementById('seedDisplay').textContent = gameState.seed;
            } else {
                document.getElementById('modeDisplay').textContent = 'Quick Maze';
                document.getElementById('level').textContent = quickMazeConfig.level;
                document.getElementById('seedDisplay').textContent = quickMazeConfig.seed;
            }
            document.getElementById('graphicsMode').textContent = windowsMode ? 'Windows' : 'Default';
        }

        // Event listeners
        document.getElementById('campaignBtn').addEventListener('click', () => {
            startGame('campaign');
        });

        document.getElementById('quickMazeBtn').addEventListener('click', () => {
            let level = parseInt(document.getElementById('quickLevel').value) || 1;
            const seed = parseInt(document.getElementById('quickSeed').value) || Date.now();
            level = Math.max(1, Math.min(8, level));
            startGame('quick', { level, seed });
        });

        document.getElementById('resetBtn').addEventListener('click', resetCurrentMaze);
        document.getElementById('menuBtn').addEventListener('click', returnToMenu);
        document.getElementById('menuBtn2').addEventListener('click', returnToMenu);

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            if (gameMode === 'campaign') {
                if (gameState.level >= 8) {
                    alert('ðŸŽ‰ Congratulations! You\'ve completed all 8 levels!\n\nStarting from Level 1 again...');
                    gameState.level = 1;
                } else {
                    gameState.level++;
                }
                gameState.seed = Date.now();
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                maze.markExplored(player.x, player.y);
                updateUI();
            } else {
                quickMazeConfig.seed = Date.now();
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                maze.markExplored(player.x, player.y);
                updateUI();
            }
        });

        // Input handling
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState.won) {
                document.getElementById('nextLevelBtn').click();
            }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        canvas.addEventListener('click', () => {
            if (!document.getElementById('startMenu').classList.contains('hidden')) return;
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (pointerLocked && player) {
                player.angle += e.movementX * 0.0014;
                player.pitch -= e.movementY * 0.0014;
                
                const maxPitch = 1.4;
                player.pitch = Math.max(-maxPitch, Math.min(maxPitch, player.pitch));
            }
        });

        // Game loop
        let lastTime = performance.now();
        const targetFPS = 60;
        const targetFrameTime = 1000 / targetFPS;

        function gameLoop(currentTime) {
            if (!document.getElementById('startMenu').classList.contains('hidden') || !maze || !player) {
                lastTime = currentTime;
                requestAnimationFrame(gameLoop);
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            const deltaMultiplier = deltaTime / targetFrameTime;
            const cappedDelta = Math.min(deltaMultiplier, 3);

            if (!gameState.won) {
                const moveX = Math.cos(player.angle) * player.moveSpeed * cappedDelta;
                const moveY = Math.sin(player.angle) * player.moveSpeed * cappedDelta;
                const strafeX = Math.cos(player.angle + Math.PI / 2) * player.moveSpeed * cappedDelta;
                const strafeY = Math.sin(player.angle + Math.PI / 2) * player.moveSpeed * cappedDelta;

                if (keys['w']) player.move(moveX, moveY, maze);
                if (keys['s']) player.move(-moveX, -moveY, maze);
                if (keys['a']) player.move(-strafeX, -strafeY, maze);
                if (keys['d']) player.move(strafeX, strafeY, maze);

                maze.markExplored(player.x, player.y);

                if (player.checkExit(maze)) {
                    gameState.won = true;
                    document.getElementById('win').style.display = 'block';
                }
            }

            player.render(maze);
            maze.drawMinimap(player.x, player.y);

            requestAnimationFrame(gameLoop);
        }

        gameLoop(performance.now());
    </script>
</body>
</html>