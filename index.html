<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Explorer 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #eee;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #startMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #startMenu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 48px;
            color: #4a90e2;
            margin-bottom: 60px;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            text-align: center;
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 400px;
        }

        .menu-item {
            background: rgba(74, 144, 226, 0.1);
            border: 2px solid #4a90e2;
            padding: 20px 30px;
            font-size: 24px;
            color: #4a90e2;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            border-radius: 8px;
        }

        .menu-item:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .menu-item.disabled {
            opacity: 0.5;
            cursor: default;
        }

        .menu-item.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .quick-maze-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .quick-maze-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-label {
            font-size: 14px;
            color: #888;
        }

        .control-input {
            background: rgba(0,0,0,0.3);
            border: 1px solid #4a90e2;
            color: #4a90e2;
            padding: 8px 12px;
            font-size: 18px;
            border-radius: 5px;
            width: 150px;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            z-index: 5;
        }

        #win {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,255,100,0.95);
            color: #000;
            padding: 40px;
            border-radius: 15px;
            font-size: 32px;
            font-weight: bold;
            display: none;
            text-align: center;
            z-index: 100;
        }

        .btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #000;
            color: #00ff88;
            border: 2px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .btn:hover {
            background: #00ff88;
            color: #000;
        }

        #resetBtn, #menuBtn {
            margin-top: 10px;
            padding: 5px 10px;
            font-size: 12px;
            background: rgba(255,51,102,0.2);
            color: #ff3366;
            border: 1px solid #ff3366;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            width: 100%;
            display: block;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <div class="menu-title">MAZE EXPLORER 3D</div>
        <div class="menu-options">
            <div class="menu-item" id="campaignBtn">CAMPAIGN MODE</div>
            <div class="quick-maze-container">
                <div class="menu-item" id="quickMazeBtn">QUICK MAZE</div>
                <div class="quick-maze-controls">
                    <div class="control-group">
                        <div class="control-label">Level (1-8)</div>
                        <input type="number" class="control-input" id="quickLevel" value="1" min="1" max="8">
                    </div>
                    <div class="control-group">
                        <div class="control-label">Seed</div>
                        <input type="number" class="control-input" id="quickSeed" value="12345">
                    </div>
                </div>
            </div>
            <div class="menu-item disabled">PATREON</div>
            <div class="menu-item disabled">PIX</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="crosshair">+</div>
    <div id="ui">
        <div>Mode: <span id="modeDisplay">Campaign</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Seed: <span id="seedDisplay">0</span></div>
        <button id="resetBtn">Reset Maze</button>
        <button id="menuBtn">Main Menu</button>
    </div>
    <div id="instructions">
        WASD - Move | Mouse - Look | Click to lock pointer
    </div>
    <div id="win">
        ðŸŽ‰ EXIT FOUND! ðŸŽ‰<br>
        <div style="font-size:16px; margin-top:10px;">Press SPACE or click below</div>
        <button class="btn" id="nextLevelBtn">Next Level</button>
        <button class="btn" id="menuBtn2">Main Menu</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Game state
        let gameMode = 'campaign';
        let quickMazeConfig = { level: 1, seed: 12345 };
        let gameState = { level: 1, seed: Date.now(), won: false };
        let maze, player;
        let pointerLocked = false;

        // Seeded random number generator
        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }

        // Maze generator
        class Maze {
            constructor(cols, rows, seed) {
                this.cols = cols;
                this.rows = rows;
                this.cellSize = 64;
                this.grid = [];
                this.rng = new Random(seed);
                
                for (let y = 0; y < rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < cols; x++) {
                        this.grid[y][x] = {
                            walls: { top: true, right: true, bottom: true, left: true },
                            visited: false
                        };
                    }
                }
                
                this.generate(0, 0);
                this.exitX = this.cols - 1;
                this.exitY = this.rows - 1;
                this.grid[this.exitY][this.exitX].isExit = true;
            }

            generate(x, y) {
                const stack = [[x, y]];
                
                while (stack.length > 0) {
                    const [cx, cy] = stack[stack.length - 1];
                    this.grid[cy][cx].visited = true;
                    
                    const directions = [
                        { dx: 0, dy: -1, wall: 'top', opposite: 'bottom' },
                        { dx: 1, dy: 0, wall: 'right', opposite: 'left' },
                        { dx: 0, dy: 1, wall: 'bottom', opposite: 'top' },
                        { dx: -1, dy: 0, wall: 'left', opposite: 'right' }
                    ];
                    
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(this.rng.next() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    let foundUnvisited = false;
                    for (const dir of directions) {
                        const nx = cx + dir.dx;
                        const ny = cy + dir.dy;
                        
                        if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows && !this.grid[ny][nx].visited) {
                            this.grid[cy][cx].walls[dir.wall] = false;
                            this.grid[ny][nx].walls[dir.opposite] = false;
                            stack.push([nx, ny]);
                            foundUnvisited = true;
                            break;
                        }
                    }
                    
                    if (!foundUnvisited) {
                        stack.pop();
                    }
                }
            }

            getCell(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                if (cellX < 0 || cellX >= this.cols || cellY < 0 || cellY >= this.rows) {
                    return null;
                }
                return this.grid[cellY][cellX];
            }
        }

        // Player with raycasting
        class Player {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.moveSpeed = 3;
                this.rotSpeed = 0.05;
                this.fov = Math.PI / 3;
                this.rayCount = canvas.width;
            }

            move(dx, dy, maze) {
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                if (!this.checkCollision(newX, this.y, maze)) {
                    this.x = newX;
                }
                if (!this.checkCollision(this.x, newY, maze)) {
                    this.y = newY;
                }
            }

            checkCollision(x, y, maze) {
                const cellX = Math.floor(x / maze.cellSize);
                const cellY = Math.floor(y / maze.cellSize);
                
                if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                    return true;
                }
                
                const cell = maze.grid[cellY][cellX];
                const localX = x % maze.cellSize;
                const localY = y % maze.cellSize;
                const margin = 8;
                
                if (localY < margin && cell.walls.top) return true;
                if (localY > maze.cellSize - margin && cell.walls.bottom) return true;
                if (localX < margin && cell.walls.left) return true;
                if (localX > maze.cellSize - margin && cell.walls.right) return true;
                
                return false;
            }

            checkExit(maze) {
                const cellX = Math.floor(this.x / maze.cellSize);
                const cellY = Math.floor(this.y / maze.cellSize);
                return cellX === maze.exitX && cellY === maze.exitY;
            }

            castRays(maze) {
                const rays = [];
                
                for (let i = 0; i < this.rayCount; i++) {
                    const rayAngle = this.angle - this.fov / 2 + (this.fov * i / this.rayCount);
                    const ray = this.castRay(rayAngle, maze);
                    rays.push(ray);
                }
                
                return rays;
            }

            castRay(angle, maze) {
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                let dist = 0;
                const step = 0.5;
                const maxDist = 1000;
                let hitWall = false;
                let isExit = false;
                let wallSide = null;
                
                while (!hitWall && dist < maxDist) {
                    dist += step;
                    const testX = this.x + dx * dist;
                    const testY = this.y + dy * dist;
                    
                    const cellX = Math.floor(testX / maze.cellSize);
                    const cellY = Math.floor(testY / maze.cellSize);
                    
                    if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                        hitWall = true;
                        break;
                    }
                    
                    const cell = maze.grid[cellY][cellX];
                    const localX = testX % maze.cellSize;
                    const localY = testY % maze.cellSize;
                    
                    if (localY < 1 && cell.walls.top) {
                        hitWall = true;
                        wallSide = 'horizontal';
                    } else if (localY > maze.cellSize - 1 && cell.walls.bottom) {
                        hitWall = true;
                        wallSide = 'horizontal';
                    } else if (localX < 1 && cell.walls.left) {
                        hitWall = true;
                        wallSide = 'vertical';
                    } else if (localX > maze.cellSize - 1 && cell.walls.right) {
                        hitWall = true;
                        wallSide = 'vertical';
                    }
                    
                    if (cell.isExit) {
                        isExit = true;
                    }
                }
                
                return { dist, angle, isExit, wallSide };
            }

            render(maze) {
                const rays = this.castRays(maze);
                
                // Sky
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
                
                // Floor
                ctx.fillStyle = '#0a0a14';
                ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
                
                // Walls
                for (let i = 0; i < rays.length; i++) {
                    const ray = rays[i];
                    const correctedDist = ray.dist * Math.cos(ray.angle - this.angle);
                    const wallHeight = (maze.cellSize * 300) / correctedDist;
                    
                    const wallTop = (canvas.height - wallHeight) / 2;
                    const wallBottom = wallTop + wallHeight;
                    
                    let brightness = Math.max(0, 1 - correctedDist / 500);
                    
                    if (ray.isExit) {
                        const r = Math.floor(0 * brightness);
                        const g = Math.floor(255 * brightness);
                        const b = Math.floor(136 * brightness);
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                    } else {
                        if (ray.wallSide === 'vertical') {
                            brightness *= 0.7;
                        }
                        const color = Math.floor(74 * brightness);
                        const color2 = Math.floor(144 * brightness);
                        const color3 = Math.floor(226 * brightness);
                        ctx.fillStyle = `rgb(${color},${color2},${color3})`;
                    }
                    
                    ctx.fillRect(i, wallTop, 1, wallHeight);
                }
                
                // Draw hand sprite
                this.drawHand();
            }

            drawHand() {
                const handWidth = 150;
                const handHeight = 200;
                const handX = canvas.width - handWidth - 20;
                const handY = canvas.height - handHeight;
                
                // Simple hand/fist sprite
                ctx.fillStyle = '#d4a574';
                
                // Palm
                ctx.beginPath();
                ctx.ellipse(handX + 60, handY + 120, 40, 50, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Fingers
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(handX + 30 + i * 15, handY + 80 + i * 5, 12, 30, -0.2 + i * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Thumb
                ctx.beginPath();
                ctx.ellipse(handX + 20, handY + 130, 15, 25, -0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Wrist
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(handX + 35, handY + 150, 50, 50);
            }
        }

        function startGame(mode, config = null) {
            gameMode = mode;
            document.getElementById('startMenu').classList.add('hidden');
            
            if (mode === 'campaign') {
                if (gameState.level > 8) gameState.level = 8;
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
            } else {
                quickMazeConfig = config;
                if (quickMazeConfig.level > 8) quickMazeConfig.level = 8;
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
            }
            
            updateUI();
            canvas.requestPointerLock();
        }

        function resetCurrentMaze() {
            if (gameMode === 'campaign') {
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
            } else {
                quickMazeConfig.seed = Date.now();
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                updateUI();
            }
        }

        function returnToMenu() {
            document.getElementById('startMenu').classList.remove('hidden');
            document.getElementById('win').style.display = 'none';
            gameState.won = false;
            document.exitPointerLock();
        }

        function updateUI() {
            if (gameMode === 'campaign') {
                document.getElementById('modeDisplay').textContent = 'Campaign';
                document.getElementById('level').textContent = gameState.level;
                document.getElementById('seedDisplay').textContent = gameState.seed;
            } else {
                document.getElementById('modeDisplay').textContent = 'Quick Maze';
                document.getElementById('level').textContent = quickMazeConfig.level;
                document.getElementById('seedDisplay').textContent = quickMazeConfig.seed;
            }
        }

        // Event listeners
        document.getElementById('campaignBtn').addEventListener('click', () => {
            startGame('campaign');
        });

        document.getElementById('quickMazeBtn').addEventListener('click', () => {
            let level = parseInt(document.getElementById('quickLevel').value) || 1;
            const seed = parseInt(document.getElementById('quickSeed').value) || Date.now();
            level = Math.max(1, Math.min(8, level));
            startGame('quick', { level, seed });
        });

        document.getElementById('resetBtn').addEventListener('click', resetCurrentMaze);
        document.getElementById('menuBtn').addEventListener('click', returnToMenu);
        document.getElementById('menuBtn2').addEventListener('click', returnToMenu);

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            if (gameMode === 'campaign') {
                if (gameState.level >= 8) {
                    alert('ðŸŽ‰ Congratulations! You\'ve completed all 8 levels!\n\nStarting from Level 1 again...');
                    gameState.level = 1;
                } else {
                    gameState.level++;
                }
                gameState.seed = Date.now();
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                const mazeSize = 5 + gameState.level * 5;
                maze = new Maze(mazeSize, mazeSize, gameState.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                updateUI();
            } else {
                quickMazeConfig.seed = Date.now();
                gameState.won = false;
                document.getElementById('win').style.display = 'none';
                const mazeSize = 5 + quickMazeConfig.level * 5;
                maze = new Maze(mazeSize, mazeSize, quickMazeConfig.seed);
                player = new Player(maze.cellSize / 2, maze.cellSize / 2, 0);
                updateUI();
            }
        });

        // Input handling
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState.won) {
                document.getElementById('nextLevelBtn').click();
            }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Pointer lock
        canvas.addEventListener('click', () => {
            if (!document.getElementById('startMenu').classList.contains('hidden')) return;
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (pointerLocked && player) {
                player.angle += e.movementX * 0.002;
            }
        });

        // Game loop
        function gameLoop() {
            if (!document.getElementById('startMenu').classList.contains('hidden') || !maze || !player) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!gameState.won) {
                // Movement
                const moveX = Math.cos(player.angle) * player.moveSpeed;
                const moveY = Math.sin(player.angle) * player.moveSpeed;
                const strafeX = Math.cos(player.angle + Math.PI / 2) * player.moveSpeed;
                const strafeY = Math.sin(player.angle + Math.PI / 2) * player.moveSpeed;

                if (keys['w']) player.move(moveX, moveY, maze);
                if (keys['s']) player.move(-moveX, -moveY, maze);
                if (keys['a']) player.move(-strafeX, -strafeY, maze);
                if (keys['d']) player.move(strafeX, strafeY, maze);

                // Check for exit
                if (player.checkExit(maze)) {
                    gameState.won = true;
                    document.getElementById('win').style.display = 'block';
                }
            }

            // Render
            player.render(maze);

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>